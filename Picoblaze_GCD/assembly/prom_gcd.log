KCPSM6 Assembler log file for program 'Y:\Documents\USC\EE354\Picoblaze_GCD\assembly\prom_gcd.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 07 Apr 2023
Assembly timestamp: 13:19:43

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 046 hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 71
Memory locations available: 4025


Assembly listing

 Addr Code                  Instruction

 000                        ; KCPSM6 Program
 000                        ; Author         - Vikram & Chethan
 000                        ; File     - prom_gcd.psm
 000                        ; Original file was made in 2017. Reviewed in March 2013.
 000                        ;**************************************************************************************
 000                        ;Port definitions:
 000                        ; Comment: We have already provided all the ports with addresses. Make sure they match the top.
 000                        ;**************************************************************************************
 000                        CONSTANT Control_signal, 00              ;port00 used for loading info of Start, Step, Ack signals
 000                        CONSTANT Ain, 01                         ;port01 used for loading info of Ain
 000                        CONSTANT Bin, 02                         ;port02 used for loading info of Bin
 000                        CONSTANT A_Value, 00                     ;port00 used for outputting A
 000                        CONSTANT B_Value, 01                     ;port01 used for outputting B
 000                        CONSTANT AB_GCD, 02                      ;port02 used for outputting AB_GCD
 000                        CONSTANT i_count, 03                     ;port03 used for outputting i_count
 000                        CONSTANT Current_State, 04               ;port04 used for outputting current state info to LEDs
 000                        CONSTANT Control_Signal_Ack, 05          ;port05 used for outputting Ack for Start and Step Signals
 000                        ;**************************************************************************************
 000                        ; Special Register usage
 000                        ;**************************************************************************************
 000                        ;NAMEREG Not used here
 000                        ;**************************************************************************************
 000                        ;MAIN PROGRAM
 000                        ;**************************************************************************************
 000                        ;Control Signal Format in s8 {6'b000000,BtnU_Pulse_Reg,Start_Ack_Pulse_Reg} ; BtnU pulse indicates Step operation
 000  28001          start: ENABLE INTERRUPT
 001  01000                 LOAD s0, 00                              ; Load register s0 00000000'b
 002  01101                 LOAD s1, 01                              ; Load register s1 00000001'b  start/ack signal ack return signal
 003  01202                 LOAD s2, 02                              ; Load register s2 00000010'b  step signal received ack return signal
 004  2B014  state_initial: OUTPUTK 01[00000001'b], 4[Current_State] ; Indicating Current State as Initial State
 005  09301                 INPUT s3, 01[Ain]                        ; Register s3 holds Ain
 006  09402                 INPUT s4, 02[Bin]                        ; Register s4 holds Bin
 007  01500                 LOAD s5, 00                              ; Register s5 holds i_count
 008  01602                 LOAD s6, 02[AB_GCD]                      ; Register s6 holds AB_GCD
 009  01700                 LOAD s7, 00                              ; Temporary Register s7 for swapping A and B
 00A  09800                 INPUT s8, 00[Control_signal]             ; Load the Control Signal Information into register s8
 00B  03801                 AND s8, 01[00000001'b]                   ; Check to see if Start Control Signal is set using 00000001'b Mask
 00C  32004                 JUMP Z, 004[state_initial]               ; Jump back to state_initial and keep looking for the Start signal
 00D  2D105                 OUTPUT s1, 05[Control_Signal_Ack]        ; Ack the start signal by setting the start_ack = 1
 00E  2D005                 OUTPUT s0, 05[Control_Signal_Ack]        ; Reset the Acknowledge signal so start can be pressed again
 00F  22010                 JUMP 010[state_SUB]                      ; Jump to Subtract State if Start is pressed
 010                        ;***************************************************************************************
 010                        ;Subtract State
 010                        ;****************************************************************************************
 010  2B024      state_SUB: OUTPUTK 02[00000010'b], 4[Current_State] ; TODO: Indicating Current State as Subtract State
 011  2D300                 OUTPUT s3, 00[A_Value]
 012  2D401                 OUTPUT s4, 01[B_Value]
 013  09800                 INPUT s8, 00[Control_signal]             ; Load the Control Signal Information into register s8
 014  03802                 AND s8, 02[00000010'b]                   ; Check to see if Step Control Signal is set using 00000010'b Mask
 015  32010                 JUMP Z, 010[state_SUB]                   ; Keep looking for Step (BtnU_Pulse_Reg)
 016  2D205                 OUTPUT s2, 05[Control_Signal_Ack]        ; Ack the step signal by setting the step_ack = 1
 017  2D005                 OUTPUT s0, 05[Control_Signal_Ack]        ; Reset the Acknowledge signal so step can be pressed again
 018  1C340                 COMPARE s3, s4                           ; is s3 - s4 (compare)?
 019  3202F                 JUMP Z, 02F[assign_GCD]                  ; if equal jump to GCD Assignment
 01A  3A02B                 JUMP C, 02B[swap_AB]                     ; If A < B, swap A and B
 01B  0D301                 TEST s3, 01                              ; Since A > B, TEST - Carry flag is set if there are odd number of 1s in the temporary result
 01C  32021                 JUMP Z, 021[A_Even]                      ; A[0] is 0 => A is even
 01D  0D401                 TEST s4, 01                              ; A is odd. Check for B
 01E  32027                 JUMP Z, 027[A_Odd_B_Even]                ; B[0] is 0 => B is even
 01F  18340    A_Odd_B_Odd: SUB s3, s4                               ; A is Odd, B is Odd. A <= A - B;
 020  22010                 JUMP 010[state_SUB]                      ; Now jump back to beginning of state_SUB
 021  0D401         A_Even: TEST s4, 01                              ; A is even. Check for B
 022  36029                 JUMP NZ, 029[A_Even_B_Odd]               ; B is Odd if Carry Set => Jump to A_Even_B_Odd
 023  11501  A_Even_B_Even: ADD s5, 01                               ; i_count <= i_count + 1;
 024  1430E                 SR0 s3                                   ; A <= A/2;
 025  1440E                 SR0 s4                                   ; B <= B/2;
 026  22010                 JUMP 010[state_SUB]                      ; Now jump back to beginning of state_SUB
 027  1440E   A_Odd_B_Even: SR0 s4                                   ; B <= B/2;
 028  22010                 JUMP 010[state_SUB]                      ; Now jump back to beginning of state_SUB
 029  1430E   A_Even_B_Odd: SR0 s3                                   ; A <= A/2;
 02A  22010                 JUMP 010[state_SUB]                      ; Now jump back to beginning of state_SUB
 02B  00730        swap_AB: LOAD s7, s3                              ; temp_reg = A
 02C  00340                 LOAD s3, s4                              ; A = B
 02D  00470                 LOAD s4, s7                              ; B = temp_reg
 02E  22010                 JUMP 010[state_SUB]
 02F  00630     assign_GCD: LOAD s6, s3                              ; Load A as GCD
 030  1D500                 COMPARE s5, 00                           ; Check if i_count is 0 ; notice that we check if (i==0) in hardware also
 031  3203E                 JUMP Z, 03E[state_DONE]                  ; If i_count is 0 jump to done state
 032  22033                 JUMP 033[state_MULT]                     ; if not jump to MULT state
 033                        ;****************************************************************************************
 033                        ;MULT State
 033                        ;****************************************************************************************
 033  2B044     state_MULT: OUTPUTK 04[00000100'b], 4[Current_State] ; TODO: Indicating Current State as MULT State
 034  2D503                 OUTPUT s5, 03[i_count]
 035  2D602                 OUTPUT s6, 02[AB_GCD]
 036  09800                 INPUT s8, 00[Control_signal]             ; Load the Control Signal Information into register s8
 037  03802                 AND s8, 02[00000010'b]                   ; Check to see if Step Control Signal is set using 00000010'b Mask
 038  32033                 JUMP Z, 033[state_MULT]                  ; Wait till Step (BtnU_Pulse_Reg) is received
 039  2D205                 OUTPUT s2, 05[Control_Signal_Ack]        ; Ack the step signal by setting the step_ack = 1
 03A  2D005                 OUTPUT s0, 05[Control_Signal_Ack]        ; Reset the Acknowledge signal so step can be pressed again
 03B  14606                 SL0 s6                                   ; GCD = GCD*2
 03C  19501                 SUB s5, 01                               ; i_count = i_count - 1
 03D  36033                 JUMP NZ, 033[state_MULT]                 ; Loop back to MULT state if i_count!=0; notice that we check if (i==1) in hardware
 03E                        ;****************************************************************************************
 03E                        ;Done State
 03E                        ;****************************************************************************************
 03E  2B084     state_DONE: OUTPUTK 08[00001000'b], 4[Current_State] ; Indicating Current State as Done State
 03F  2D503                 OUTPUT s5, 03[i_count]
 040  2D602                 OUTPUT s6, 02[AB_GCD]
 041  09800                 INPUT s8, 00[Control_signal]             ; Load the Control Signal Information into register s8
 042  03801                 AND s8, 01[00000001'b]                   ; Check to see if ACK is received
 043  3203E                 JUMP Z, 03E[state_DONE]                  ; Jump to state_initial until ACK is received
 044  2D105                 OUTPUT s1, 05[Control_Signal_Ack]        ; Ack the ACK signal by setting the start_ack = 1
 045  2D005                 OUTPUT s0, 05[Control_Signal_Ack]        ; Reset the Acknowledge signal so start can be pressed next in the state_initial
 046  22004                 JUMP 004[state_initial]                  ; Go to state_initial to start all over


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

Y:\Documents\USC\EE354\Picoblaze_GCD\assembly\prom_gcd.psm



List of defined constants

 CONSTANT name      Value        Source PSM File

 timestamp_hours    13'd         
 timestamp_minutes  19'd         
 timestamp_seconds  43'd         
 datestamp_year     23'd         
 datestamp_month    4'd          
 datestamp_day      07'd         
 NUL                00           
 BEL                07           
 BS                 08           
 HT                 09           
 LF                 0A           
 VT                 0B           
 CR                 0D           
 ESC                1B           
 DEL                7F           
 DCS                90           
 ST                 9C           
 Control_signal     00           prom_gcd.psm
 Ain                01           prom_gcd.psm
 Bin                02           prom_gcd.psm
 A_Value            00           prom_gcd.psm
 B_Value            01           prom_gcd.psm
 AB_GCD             02           prom_gcd.psm
 i_count            03           prom_gcd.psm
 Current_State      04           prom_gcd.psm
 Control_Signal_Ack 05           prom_gcd.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "07 Apr 2023"  
 timestamp$        "13:19:43"     



List of line labels

   Label           Addr  Source PSM File

 * start           000   prom_gcd.psm
   state_initial   004   prom_gcd.psm
   state_SUB       010   prom_gcd.psm
 * A_Odd_B_Odd     01F   prom_gcd.psm
   A_Even          021   prom_gcd.psm
 * A_Even_B_Even   023   prom_gcd.psm
   A_Odd_B_Even    027   prom_gcd.psm
   A_Even_B_Odd    029   prom_gcd.psm
   swap_AB         02B   prom_gcd.psm
   assign_GCD      02F   prom_gcd.psm
   state_MULT      033   prom_gcd.psm
   state_DONE      03E   prom_gcd.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             10
 STAR              -

 AND               4
 OR                -
 XOR               -

 ADD               1
 ADDCY             -
 SUB               2
 SUBCY             -

 TEST              3
 TESTCY            -
 COMPARE           2
 COMPARECY         -

 SL0               1
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               4
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             6
 OUTPUT           14
 OUTPUTK           4

 STORE             -
 FETCH             -

 DISABLE           -
 ENABLE            1
 RETURNI           -

 JUMP             19
 JUMP@             -
 CALL              -
 CALL@             -
 RETURN            -
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
